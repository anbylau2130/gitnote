<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-323f8104-cff9-48ae-8a40-ba877ce68a0c"></attachment><h1>6.分类模型的评估6.分类模型的评估</h1><p>MarkdownHTML</p><p># 分类模型的评估</p><p><br></p><p>estimator.score()</p><p><br></p><p>一般最常见使用的是准确率，即预测结果正确的百分比</p><p><br></p><p># 混淆矩阵</p><p>在分类任务下，预测结果与正确标记之间存在四种不同的组合，构成混淆矩阵（适用于多分类）</p><p><br></p><p>![](6.分类模型的评估_files/5c4fe75cad653a20c3000005.png)</p><p><br></p><p># 准确率</p><p>预测结果为正例样本中真是为正例的比例（查得准）</p><p><br></p><p># 召回率</p><p>真实为正例的样本（查的全，对正样本的区分能力）</p><p> </p><p> </p><p># F1-Score 反映了模型的稳健性</p><p> ![](6.分类模型的评估_files/5c4fe833ad653a20c3000006.png)</p><p> </p><p># 分类模型评估API</p><p><br></p><p>## sklearn.metrics.classification_report</p><p><br></p><p>### sklearn.metics.classfication_report(y_true,y_pred,target_names=None)</p><p>- y_true 真是目标值</p><p>- y_pred 估计器预测目标值</p><p>- target_names 目标类别名称</p><p>- return  每个类别精确率与召回率</p><p><br></p><p>```</p><p><br></p><p>from sklearn.naive_bayes import MultinomialNB</p><p>from sklearn.datasets import fetch_20newsgroups</p><p>from sklearn.model_selection import train_test_split</p><p>from sklearn.feature_extraction.text import TfidfVectorizer</p><p>from sklearn.metrics import classification_report</p><p><br></p><p>news=fetch_20newsgroups(subset="all")</p><p># 分割数据集</p><p>x_trains,x_test,y_trains,y_test=train_test_split(news.data,news.target)</p><p><br></p><p># tf idf进行分词</p><p>tf=TfidfVectorizer()</p><p><br></p><p>x_trains=tf.fit_transform(x_trains)</p><p><br></p><p>x_test=tf.fit_transform(x_test)</p><p><br></p><p># 朴素贝叶斯 进行数据训练</p><p>mlt=MultinomialNB(alpha=1.0)</p><p># 获取预测结果</p><p>y_predict=mlt.fit(x_trains,y_trains)</p><p># 统计预测准确率</p><p>p=mlt.score(x_test,y_test)</p><p><br></p><p># 预估准确性测试</p><p>classification_report(y_test,y_predict,target_names=news.target_names)</p><p>print(p)</p><pre class="ql-syntax" spellcheck="false">```  # 分类模型的评估

estimator.score()

一般最常见使用的是准确率，即预测结果正确的百分比

# 混淆矩阵
在分类任务下，预测结果与正确标记之间存在四种不同的组合，构成混淆矩阵（适用于多分类）

![](6.分类模型的评估_files/5c4fe75cad653a20c3000005.png)

# 准确率
预测结果为正例样本中真是为正例的比例（查得准）

# 召回率
真实为正例的样本（查的全，对正样本的区分能力）
 
 
# F1-Score 反映了模型的稳健性
 ![](6.分类模型的评估_files/5c4fe833ad653a20c3000006.png)
 
# 分类模型评估API

## sklearn.metrics.classification_report

### sklearn.metics.classfication_report(y_true,y_pred,target_names=None)
- y_true 真是目标值
- y_pred 估计器预测目标值
- target_names 目标类别名称
- return  每个类别精确率与召回率

```

from sklearn.naive_bayes import MultinomialNB
from sklearn.datasets import fetch_20newsgroups
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import classification_report

news=fetch_20newsgroups(subset="all")
# 分割数据集
x_trains,x_test,y_trains,y_test=train_test_split(news.data,news.target)

# tf idf进行分词
tf=TfidfVectorizer()

x_trains=tf.fit_transform(x_trains)

x_test=tf.fit_transform(x_test)

# 朴素贝叶斯 进行数据训练
mlt=MultinomialNB(alpha=1.0)
# 获取预测结果
y_predict=mlt.fit(x_trains,y_trains)
# 统计预测准确率
p=mlt.score(x_test,y_test)

# 预估准确性测试
classification_report(y_test,y_predict,target_names=news.target_names)
print(p)
</pre><p>```  </p><p> function init() { markdownToHtml(document.getElementById('leanote-content-markdown').value, document.getElementById('leanote-content-html'), function(html) { // 解析后执行 if(window.markdownParsed) { window.markdownParsed(html); } }); var $m = document.getElementById('tab-markdown'); var $h = document.getElementById('tab-html'); var $cc = document.getElementById('content-container'); function toggleToHtml(isToHtml) { $cc.className = isToHtml ? 'content-container html' : 'content-container'; } $m.addEventListener('click', function() { toggleToHtml(false); }); $h.addEventListener('click', function() { toggleToHtml(true); }); } // 如果不要自动解析html, notParseMarkdown在leanote-markdown.js中定义 if(!window.notParseMarkdown) { init(); } </p>