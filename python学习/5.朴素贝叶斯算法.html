<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-fa57155c-f240-4cb1-8112-3d80a14a2290"></attachment><h1>5.朴素贝叶斯算法5.朴素贝叶斯算法</h1><p>MarkdownHTML</p><p># 不需要调参数</p><p><br></p><p># 联合概率</p><p>包含多个条件，且所有条件同时成立的概率</p><p>![](5.朴素贝叶斯算法_files/5c4fb660ad653a20c3000000.png)</p><p># 条件概率</p><p>![](5.朴素贝叶斯算法_files/5c4fb669ad653a20c3000001.png)</p><p><br></p><p><br></p><p># 朴素贝叶斯 </p><p>特征是条件独立时才能使用</p><p><br></p><p># 朴素贝叶斯公式</p><p>![](5.朴素贝叶斯算法_files/5c4fb8a7ad653a20c3000002.png)</p><p><br></p><p>![](5.朴素贝叶斯算法_files/5c4fb992ad653a20c3000003.png)</p><p><br></p><p><br></p><p><br></p><p># 解决概率为0的情况</p><p>![](5.朴素贝叶斯算法_files/5c4fbb6bad653a20c3000004.png)</p><p><br></p><p><br></p><p># 朴素贝叶斯 API</p><p>## sklearn.naive_bayes.MultinomialNB</p><p><br></p><p>### MultinomialNB(alpha=1.0)</p><p>- 朴素贝叶斯分类</p><p>- alpha:拉普拉斯平滑系数</p><p><br></p><p>训练集误差大，结构肯定不准确</p><p><br></p><p><br></p><p><br></p><p># 优点</p><p>- 朴素贝叶斯是模型发源于古典数据理论，有稳定的分类效率</p><p>- 对缺失数据不太敏感，算法也比较简单。常用于文章分类</p><p>- 分类准确度高，速度快</p><p><br></p><p># 缺点</p><p>由于使用了样本属性独立性的假设，所以如果样本属性有关联时其效果不好</p><p><br></p><p><br></p><p># 案例</p><p>```</p><p>from sklearn.naive_bayes import MultinomialNB</p><p>from sklearn.datasets import fetch_20newsgroups</p><p>from sklearn.model_selection import train_test_split</p><p>from sklearn.feature_extraction.text import TfidfVectorizer</p><p>news=fetch_20newsgroups(subset="all")</p><p># 分割数据集</p><p>x_trains,x_test,y_trains,y_test=train_test_split(news.data,news.target)</p><p><br></p><p># tf idf进行分词</p><p>tf=TfidfVectorizer()</p><p><br></p><p>x_trains=tf.fit_transform(x_trains)</p><p><br></p><p>x_test=tf.fit_transform(x_test)</p><p><br></p><p># 朴素贝叶斯 进行数据训练</p><p>mlt=MultinomialNB(alpha=1.0)</p><p># 获取预测结果</p><p>y_predict=mlt.fit(x_trains,y_trains)</p><p># 统计预测准确率</p><p>p=mlt.score(x_test,y_test)</p><p>print(p)</p><p><br></p><p>```</p><p><br></p><p><br></p><pre class="ql-syntax" spellcheck="false">   # 不需要调参数

# 联合概率
包含多个条件，且所有条件同时成立的概率
![](5.朴素贝叶斯算法_files/5c4fb660ad653a20c3000000.png)
# 条件概率
![](5.朴素贝叶斯算法_files/5c4fb669ad653a20c3000001.png)


# 朴素贝叶斯 
特征是条件独立时才能使用

# 朴素贝叶斯公式
![](5.朴素贝叶斯算法_files/5c4fb8a7ad653a20c3000002.png)

![](5.朴素贝叶斯算法_files/5c4fb992ad653a20c3000003.png)



# 解决概率为0的情况
![](5.朴素贝叶斯算法_files/5c4fbb6bad653a20c3000004.png)


# 朴素贝叶斯 API
## sklearn.naive_bayes.MultinomialNB

### MultinomialNB(alpha=1.0)
- 朴素贝叶斯分类
- alpha:拉普拉斯平滑系数

训练集误差大，结构肯定不准确



# 优点
- 朴素贝叶斯是模型发源于古典数据理论，有稳定的分类效率
- 对缺失数据不太敏感，算法也比较简单。常用于文章分类
- 分类准确度高，速度快

# 缺点
由于使用了样本属性独立性的假设，所以如果样本属性有关联时其效果不好


# 案例
```
from sklearn.naive_bayes import MultinomialNB
from sklearn.datasets import fetch_20newsgroups
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
news=fetch_20newsgroups(subset="all")
# 分割数据集
x_trains,x_test,y_trains,y_test=train_test_split(news.data,news.target)

# tf idf进行分词
tf=TfidfVectorizer()

x_trains=tf.fit_transform(x_trains)

x_test=tf.fit_transform(x_test)

# 朴素贝叶斯 进行数据训练
mlt=MultinomialNB(alpha=1.0)
# 获取预测结果
y_predict=mlt.fit(x_trains,y_trains)
# 统计预测准确率
p=mlt.score(x_test,y_test)
print(p)

```


</pre><p>   </p><p> function init() { markdownToHtml(document.getElementById('leanote-content-markdown').value, document.getElementById('leanote-content-html'), function(html) { // 解析后执行 if(window.markdownParsed) { window.markdownParsed(html); } }); var $m = document.getElementById('tab-markdown'); var $h = document.getElementById('tab-html'); var $cc = document.getElementById('content-container'); function toggleToHtml(isToHtml) { $cc.className = isToHtml ? 'content-container html' : 'content-container'; } $m.addEventListener('click', function() { toggleToHtml(false); }); $h.addEventListener('click', function() { toggleToHtml(true); }); } // 如果不要自动解析html, notParseMarkdown在leanote-markdown.js中定义 if(!window.notParseMarkdown) { init(); } </p>